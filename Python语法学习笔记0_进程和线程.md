##Python语法学习笔记进程和线程

**人生苦短,快用Python.**

本文是Python语法学习的第6篇笔记,学习过程中主要参考了[廖雪峰的Python教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)和[菜鸟教程Python3篇](https://www.runoob.com/python3/python3-tutorial.html),在此一并表示感谢.在参考这两处资源的同时,部分内容加入了我个人的理解,如有疏漏,欢迎各位朋友与我进行深入浅出的交流 <developerqingyun@gmail.com>

###进程和线程的概念

多任务并行就是操作系统可以同时运行多个任务,例如一边用浏览器上网听音乐,一边运行Python程序,一边爬虫.

多任务并行执行时,单核CPU操作系统会轮流让各个任务交替执行,例如任务1执行0.01秒,切换到任务2执行0.01秒,再切换到任务3执行0.01秒.各个任务交替执行,但是由于CPU的执行速度很快,给人的感觉是所有任务是同时执行的.

真正的多任务并行执行只能在多核CPU上实现,但是由于任务数量多于CPU的核心数量,所以操作系统也会自动把多个任务轮流调度到每个核心上执行.

对于操作系统来说,一个任务就是一个进程(Process).例如打开一个浏览器就是启动一个浏览器进程,打开一个PyCharm就启动了一个PyCharm进程.

有些进程会同时进行多个任务,例如Word打字,拼写检查等同时进行.在一个进程内部,同时执行多个任务,把进程内的这些任务称为线程(Thread).

每个进程至少执行一个任务,所以一个进程至少有一个线程.多个线程也可以同时执行,多线程的执行方式和多进程是一样的,也是由操作系统在多个线程之间快速切换,让每个线程短暂交替执行,真正的同时执行多线程需要多核CPU才可能实现.

###要同时执行多个任务怎么办?

1 多进程模式:启动多个进程,每个进程中值开启一个线程,多个进程同时执行多个任务.

2 多线程模式:只启动一个进程,但是这个进程中开启多个线程,多个线程同时执行多个任务.

3 多进程+多线程模式:启动多个进程,每个进程再启动多个线程.

同时执行多个任务时,各个任务之间通常并不是没有关联的,而是需要相互通信和协调.有肯任务1必须暂停等待任务2完成后才能继续执行,有可能任务3和任务4又不能同时执行.

Python既支持多进程,又支持多线程.

如何调度进程和线程完全由操作系统决定,程序自己不能决定什么时候执行,执行多长时间.

###获取进程的ID

1 获取当前线程ID `getpid()` ; 获取当前线程父线程的ID `getppid()`

Unix,Linux操作系统都提供了`fork()`函数供系统调用,`fork()`函数非常特殊.操作系统调用`fork()`函数后,会自动把当前进程(称为父进程)复制一份(称为子进程).普通的函数调用,只会有一个返回值.而系统调用`fork()`函数后,调用一次,会有2个返回值,一个返回值是0,另外一个返回值是子进程的ID.这样做是因为一个父进程可以fork出很多子进程,所以父进程要记下每个子进程的ID,而子进程只需要调用`getppid()`函数就可以拿到父进程的ID.例如:

```
import os

print('进程 (%s) 开启' % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid == 0:
    print('11111')
    print('我是子进程: %s and 父进程ID是 %s.' % (os.getpid(), os.getppid()))
    print('22222')
else:
    print('333333')
    print('父进程ID是: %s 创建了子进程 (%s).' % (os.getpid(), pid))
    print('44444')

```
输出结果:

```
进程 (709) 开启
333333
父进程ID是: 709 创建了子进程 (710).
44444
11111
我是子进程: 710 and 父进程ID是 709.
22222

```

###创建多进程的3种方法

**1 使用`os`模块封装的`fork()`函数**

**2 使用`multiprocessing`模块提供的`Process`类来创建进程对象.**

```
from multiprocessing import Process
import os

def run_proc(name):
    print('运行子进程 %s (%s)...' % (name, os.getpid()))

if __name__=='__main__':
    print('当前进程,也即父进程的id是: %s.' % os.getpid())
    #创建子进程
    p = Process(target=run_proc, args=('test',))
    print('子进程即将启动')
    # 调用start()函数启动子进程
    p.start()
    #join()方法用于等待子进程结束后,再继续往下运行,通常用于进程间的同步
    p.join()
    print('子进程关闭')

```

输出结果:

```
当前进程,也即父进程的id是: 890.
子进程即将启动
运行子进程 test (891)...
子进程关闭

```

其中`p = Process(target=run_proc, args=('test',))`的第一个参数`target`是要调用的函数的名称,第二个参数args是创建的子进程自己命名的名称.

**3 用进程池Pool批量创建子进程**

如果要启动大量的子进程,可以用进程池批量创建子进程.

```
from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print('任务 task %s 由子进程 %s 执行' % (name, os.getpid()))

if __name__=='__main__':
    print('当前进程/父进程的ID是 %s' % os.getpid())
    p = Pool(8)
    for i in range(10):
        p.apply_async(long_time_task, args=(i,))
    print('等待所有子进程中的任务执行完毕')
    p.close()
    p.join()
    print('所有子进程中的任务执行完毕')

```

输出结果:

```
当前进程/父进程的ID是 1280
等待所有子进程中的任务执行完毕
任务 task 0 由子进程 1281 执行
任务 task 1 由子进程 1282 执行
任务 task 2 由子进程 1283 执行
任务 task 3 由子进程 1284 执行
任务 task 4 由子进程 1285 执行
任务 task 5 由子进程 1286 执行
任务 task 6 由子进程 1287 执行
任务 task 8 由子进程 1281 执行
任务 task 9 由子进程 1282 执行
任务 task 7 由子进程 1288 执行
所有子进程中的任务执行完毕

```

进程池中默认的进程数量是4.因为`p = Pool(8)`中传的参数为8,所以以上输出结果中执行10个任务可以看到8个ID不同的进程异步执行10个任务.如果没有传进程的数量`p = Pool()`,那么执行这10个任务的进程的数量就是4.

Pool对象调用join()方法后,所有子进程中的任务执行完毕后,join()后的代码才会继续往后执行;调用join()之前必须先调用close(),调用close()之后就不能继续添加新的进程Process了.

###子进程













